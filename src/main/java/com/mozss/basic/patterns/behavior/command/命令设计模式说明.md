- 命令模式将请求封装为一个对象，使发出请求的责任和执行请求的责任分隔开。


###引进
#####生活举例（这里插入图片或者文字简短描述）
#####UML结构图
![KBf9Gq.png](https://s2.ax1x.com/2019/10/26/KBf9Gq.png)
#####模式涉及到的角色
######客户角色（Client）：
创建一个具体命令（ConcreteCommand）对象并确定其接收者
######命令角色（Command）:
声明了一个给所有具体命令类的抽象接口，这是一个抽象角色，通常由一个Java接口或者Java抽象类实现
######具体命名角色（ConcreteComm）：
定义一个接收者和行为之间的弱耦合；实现execute()方法，复制调用接收者的相应操作
######请求者角色（Invoker）:
负责调用命令对象执行请求，相关的方法叫做行动方法
######接收者角色（Recevier）:
负责实施和执行一个请求，任何一个类都可以称为接收者，实施和执行请求的方法叫做行动方法
#####模式的几种形态（可有可无）
######一：
######二：

###Demo实现
#####例子一：
#####例子二：

###应用
#####“回呼”
#####需要在不同的时间指定请求，将请求排队
#####“撤消undo”
#####恢复
#####交易“transaction”

###实现
#####“重”or“轻”
命令应该设计得“重”或者“轻”，在不同的情况下，可以做不同的选择。如果把命令设计得“轻”，那么它只是提供了一个请求者和接收者之间的耦合，命令
代表请求者实现请求。

相反，如果把命名设计得“重”，那么它就应当实现所有的细节，包括请求所代表的操作，而不是需要接收者了，当一个系统没有接收者时，就可以使用这种做法。
#####“undo”和“redo”
如果一个命令类提供一个方法，比如叫unExecute(),以恢复其操作的效果，那么命令类就可以支持undo和redo。具体需要存储状态信息包括<br>

- 接收者对象实际上实施请求所代表的操作；
- 对接收者对象所作的操作所需要的参数；
- 接收者类的最初的状态。接收者必须提供适当的方法，使命令类可以通过调用这个方法，以便接收类恢复原有状态。

如果只需要提供一层的undo和redo,那么系统只需要存储最后被执行的那个命名对象。如果需要多层的undo和redo,那么系统就需要存储被执行过的命令
的清单，清单能允许的最大的长度便是系统所支持的undo和redo的层数，沿着清单逆着执行清单上的命名的反命令（unExecute()）便是undo;
沿着清单顺序执行就是redo。


###开源框架中使用情况
#####框架一
#####框架二

###优缺点
#####优点
- 把请求一个操作的对象与知道怎么执行一个操作的对象分割开；
- 命令类与其他任何别的类一样，可以修改和推广；
- 你可以把命令对象聚合在一起，合成为合成命令。比如宏命令就是合成命令。合成命令是对合成模式的应用；
- 由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。
#####缺点
- 使用命令模式会导致某些系统有过多的具体命令类，某些系统可能需要几十个，几百个，甚至几千个具体命令类，这使得命名模式在这样的系统里变得
不实际。

###与其他模式的区别与联系
#####与合成模式的关系
![KBRTjU.png](https://s2.ax1x.com/2019/10/26/KBRTjU.png)
#####与备忘录模式的关系
![KBWAUA.png](https://s2.ax1x.com/2019/10/26/KBWAUA.png)
#####与原型模型模式的关系
![KBWdrF.png](https://s2.ax1x.com/2019/10/26/KBWdrF.png)

###总结


