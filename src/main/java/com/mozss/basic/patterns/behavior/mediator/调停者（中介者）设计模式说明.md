- 调停者模式定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。

###引进
该模式是最容易被滥用的模式
#####使用该模式的目的
![KcnIGq.png](https://s2.ax1x.com/2019/10/28/KcnIGq.png)
#####对行为的封装
一个对象所封装的是对象的行为，而面向对象的设计的中心问题是如何体现系统的行为。因为一个系统的行为不仅仅存在于一个对象里面，而是同时存在
于很多对象里面，并且存在这些对象之间的相互作用之中。因此，一个设计恰当地体现系统的行为并不是一个容易的事情。

一个对象往往要与几个对象发生相互作用，就好比在一个小组工作的人一样，每一个人与其他同事发生相互作用。这是，一个直截了当，不好的设计就会
把这些与其他的对象直接固定到每一个对象上面。这样做的结果自然是是这些对象独立演进的难度增加，使每一个对象的变化都会影响到所有与之发生
相互作用的对象。这就好比每一个在小组中工作的人都要成为其他人的经理，不仅要管理自己，还要管理所有的同事。

在现实世界中，没有一个小组能在这样过度耦合的组织结构中完成任何事情。想象一个小组只有三个人，那么三个人之间就有三个相互关系，如果小组的
规模扩大到5人，这种相互关系就增加到10个，增长的速度是组合数式的，增长速度比指数增长的速度还要快。

在实际工作中，一个有效的管理制度，是给这个小组配备一个小组长，负责协调小组成员之间的关系。小组的同事通过小组长可以形成整个小组的行为。
这实际上就是调停者的思想。
#####
在调停者模式中，所有的成员对象都可以协调工作，但是又不能直接相互管理。这些对象都与一个处于中心地位的调停者对象发生紧密的关系，由这个调停者
对象进行协调工作。这个协调对象叫做中间者（Mediator），而被协调的成员对象叫做同事（Colleague）对象。

在Colleague对象内部发生的事件会影响到所有的同事，但是这种影响不是直接管理的方式传到其他的对象上面。记住在小组的成员增加时，这样的相互
关系是以比指数更快的方式增加的。相反，这种影响仅仅只是直接影响到调停者对象，而调停者对象反过来会协调其他的同事，形成整个系统的行为。
####生活案例
WTO就是一个协调组织，各个贸易区可以通过WTO组织进行协调。WTO扮演的正是调停者的角色，它取代了冤案本有各个贸易地区自行进行相互协调和谈判
的强耦合的关系。


#####UML结构图
![KcMPVe.png](https://s2.ax1x.com/2019/10/28/KcMPVe.png)
#####模式涉及到的角色
######抽象调停者角色：
定义出同事对象到调停者对象的接口，其中主要的方法是一个（或者多个）事件方法。在有些情况下，这个抽象对象可以忽略，一般而言，这个角色由一个
Java抽象类或者Java对象实现。
######具体调停者角色：
从抽象调停者继承而来，实现了抽象超类所声明的事件方法。具体调停者知晓所有的具体同事类，它从具体同事对象接收消息，向具体同事对象发出命令。
一般而言，这个角色由一个具体Java类实现。
#####抽象同事类角色：
定义出调停者到同事对象接口。同事对象只知道调停者而不知道其他的同事对象。一般而言，这个角色由一个Java抽象类或者Java对象实现。
#####具体同事类角色：
所有的具体同事类钧从抽象同事类继承而来，每一个具体同事类都很清楚它自己在小范围内的行为，而不知道它在大氛围内的目的。
#####模式的几种形态（可有可无）
######一：
######二：

###实现
#####具体同事对象的创建
在很多情况下，这些具体同事对象均是由一个对象创建的。这个对象也可以把调停者类作为内部类，这样的做法是系统更加强壮。
#####具体调停者对象的内部状态
在决定实现调停者模式的时候，设计师还要做出有一些重要的决定。一个重要的决定就是谁应当负责维护调停者对象的内部状态。

一般而言，可以选择同事对象维护所有的具体调停者对象的内部状态，也可以让每一个具体调停者对象自己维护自己的内部状态。
#####是否使用抽象调停者
如果非常肯定具体调停者角色只有一个的话，可以省略抽象调停者类，如果同时存在多个具体调停者角色的话，就有可能会在这些具体调停者角色中发现
共同的代码。这样一来，就需要一个共同的类型，并将重复的代码移到超类中。
#####是否使用抽象调停者
如果非常肯定具体调停者只有一个的话，就可以省略抽象调停类。如果同时存在多个具体调停者对象的话，就有可能会在这些具体调停者角色中发现共同的
代码。这样一来，就需要一个共同的类型，并将重复的代码移到超类中。
#####同时类如何与调停者通信
同时对象可以将它们自身作为参量传给调停者对象。

###迪米特法则
迪米特法则：“只与你直接的朋友们通信”。该原则要求每一个对象与其对象的相互关系是短程的，只有要可能，朋友的数量越少越好。换言之，一个对象
只应当知道他的直接合作者的接口。

调停者模式创造出一个调停者对象，将系统中有关的对象所引用的其他对象数量减少到最少，使得一个对象与其同事的相互作用被这个对象与调停者的相互作用
所取代。显然，调停者模式是迪米特法则的一个具体应用。

###使用条件
大多数对模式的研究集中于模式应当在什么情况下使用，却往往忽视这些模式不应当在什么情况下使用，调停者模式是被常常滥用的模式，但与其他几个模式
不同的是，调停者模式常常在一个很糟的设计中使用。
#####不应当在责任划分混乱时使用
通常情况下，一个初级设计师在面向对象的及时使用不熟悉的时候，会是一个系统在责任的分割上发生混乱。责任分割的混乱会使得系统的对象与对象之间
产生不适当的复杂关系。

这时候，一个很糟糕的想法就是继续这个错误，并且使用调停者模式来“化解”这一团乱麻。实际上，这样一来，责任错误划分的混乱不但不会得到改正，而且
会制造出一个莫名其妙的怪物：一个处于一团乱麻之中的混乱之首。
#####不应当对“数据类”和“方法类”
初级设计师常常会设计出这样的一种系统：让一系列之含有数据，另一些类只含有方法。比如，描述一个客户时，这些设计师首先设计一个叫做客户数据的
类，只含有客户的数据；另外再设计有一个“管理类”，含有操作客户以及此客户购买公司产品，付账的方法。管理类自然就会涉及到其他的类，诸如：产品数据
类，订单数据类，付账数据类，应收账数据类。

如此一来，“管理类”就变成了一个操作所有的数据类的方法类，这就很没有道理的设计，但是有些设计师错误地把这叫做“调停者模式”的应用。
#####正确理解封装
封装首先是行为，以及行为所涉及的状态的封装。行为与状态是不应当分割开来的。

调停者模式的用途是管理很多的对象的相互作用，以便使这些队形可以专注于自身的行为，而独立于其他的对象。上面的“管理类”则不同，因为它把
一个数据对象的内部状态取出来，在运算之后，在插入到另一个数据对象里面，这些数据对象根本没有包装任何的行为，是被动的行为接收者。显然，这
与调停者模式根本不相干。

正确的做法是让每一个类对自己的行为负责，纯数据类的划分是完全没有道理的。

在一些特殊情况下，将操作封装起来是好的设计方案，比如策略模式以及访问者模式都是将操作封装起来的设计。但是在这两种模式适用的时候，并不需
要调停者对象。其次，这些封装了操作的对象同时也封装了操作所涉及的内部状态，而没有割裂这些状态。
###实际使用情况
#####框架一
#####框架二

###优缺点
#####优点
- 适当适用调停者模式可以较少使用静态的继承关系，使得具体同事类可以更加容易地被复用。
- 适当适用调停者模式可以避免同事对象之间的过度耦合，使得调停类与同事类可以相互独立地演化。
- 调停者模式将多对多的相互作用转化为一对多的相互作用，使得对象之间的关系更加易于维护和理解。
- 调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为与其他对象的相互作用分开处理。
#####缺点
- 虽然降低了同事对象的复杂性，但代价是增加了调停者类的复杂性。当然，很多情况下，设置一个调停者比不设置更好。
- 调停类经常充满了各种具体同事类的关系协调代码，这种代码常常是不能够复用的。因此，具体同事类的复用是以调停者类的不可复用为代价的。
- 缺点三：

调停者模式为同事对象，而不是调停者对象提供了可扩展性，所以这个模式所提供的可扩展性是一种（向同事对象）倾斜的可扩展性。
###与其他模式的区别与联系
#####门面模式
![KcLIS0.png](https://s2.ax1x.com/2019/10/28/KcLIS0.png)
#####观察者模式
![KcLLTJ.png](https://s2.ax1x.com/2019/10/28/KcLLTJ.png)
#####适配器模式
![KcL7OU.png](https://s2.ax1x.com/2019/10/28/KcL7OU.png)
###总结



