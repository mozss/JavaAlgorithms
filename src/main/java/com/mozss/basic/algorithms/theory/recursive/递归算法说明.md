### 递归思想
递归(Recursion)是指在函数的定义中使用函数自身的方法
##### 递归解读
我们可以把递归分为“**递**”和“**归**”两个过程。<br>
- 递：递去，深入，分解。待解决的问题可以分解为规模较小的相同子问题。
- 归：归来，回归，合并。

我们先思考以下问题：<br>
1.待求解的问题是否可以**重复分解**成小规模的问题？<br>
2.我们“递去”到什么程度，然后“归来”呢，哪里是“最深”的地方呢？<br>
3.在“最深处”，“递去”结束前，“归来”开始前，我们面对的是**最小子问题**，面对**最小子问题**我们的解决方式是什么？<br>

只要把以上三个问题的解决了，递归可以就轻松完成了。这也就是递归的三个要素：

- 1.重复的逻辑
- 2.递归的临界点
- 3.临界点的最小子问题的处理

前两个要素是确定的。第三个要素，可以提供两种解决思路：“递去”过程中解决;“归来”规程中解决。
```java
public class recursion{

    //在递去的过程中解决问题
    function recursion_01(大规模){
        if (临界条件){      
            end; 
        }else{            
            solve;                
            recursion(小规模);  // 递去
        }
    }

    //在归来的过程中解决问题
    function recursion_02(大规模){
        if (临界条件){     
            end; 
        }else{          
            recursion(小规模);   // 递去              
            solve;     
        }
     }
}
```
##### 递归转为非递归
- 1.用变量来保存中间结果
- 2.递归调用变为循环
 
##### 递归应用
###### 汉诺塔问题
###### 阶乘问题
###### 归并排序
###### 二分查找
###### 杨辉三角问题
###### 字符串回文问题
###### 数深度问题

### 时空复杂度

### 总结
一个递归方法每次都是用不同的参数值反复调用自己，当某种参数值使得递归的方法返回，而不再调用自身，这种情况称为**边界值**，也叫基值。
当递归方法返回时，递归过程通过逐渐完成各层方法实例的未执行部分，而从最内层返回到最外层的原始调用处。

注意任何可以用递归完成的算法用栈都能实现。当我们发现递归的方法效率比较低时，可以考虑用循环或者栈来代替它。





