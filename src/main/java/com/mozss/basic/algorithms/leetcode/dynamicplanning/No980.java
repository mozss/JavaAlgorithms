package com.mozss.basic.algorithms.leetcode.dynamicplanning;

/**
 * @author mozss
 * @create 2019-09-05 14:39
 */

public class No980 {
    /**
     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * @题目名称:   980.
     * @知识考察:
     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * @题目描述:   在二维网格grid上,有4种类型的网格:
     *                  1.表示起始网格,且只有一个;
     *                  2.表示结束网格,且只有一个;
     *                  3.表示我们可以走过去;
     *                  4.-1表示我们无法走.
     *                  返回在四个方向上行走,从起始到结束方格的不同路径的数目,每一个屋障碍方格
     *                  都要通过一次.
     *
     *                  提示:
     *                      1 <= grid.length * grid[0].length <= 20;
     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * eg 1>:
     * @输入Input:    [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
     * @输出Output:   2
     * @说明:     我们有以下的路径:
     *              1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
     *              2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
     *
     * eg 2>:
     * @输入Input:    [[1,0,0,0],[0,0,0,0],[0,0,0,2]]
     * @输出Output:
     * @说明:     我们有以下四条路径：
     *              1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
     *              2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
     *              3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
     *              4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
     *
     * eg 3>:
     * @输入Input:    [[0,1],[2,0]]
     * @输出Output:   0
     * @说明:     没有一条路能完全穿过每一个空的方格一次。请注意，起始和结束方格可以位于网格中的任意位置。
     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * @解题思路:
     *          思路一：回溯法
     *              让我们尝试遍历每一个0方格，并在走过的方格留下一个障碍。
     *              回溯的时候，我们要删除那些我们自己留下障碍。
     *              介于输入数据的限制，这个方法是可以通过的，因为一个不好的路径很快就因为无法通过而被卡住。
     * @题目总结:
     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     **/

    int ans;
    int[][] grid;
    int tr, tc;
    int[] dr = new int[]{0, -1, 0, 1};
    int[] dc = new int[]{1, 0, -1, 0};
    int R, C;

    public int uniquePathsIII(int[][] grid) {
        this.grid = grid;
        R = grid.length;
        C = grid.length;

        int todo = 0;
        int sr = 0, sc = 0;
        for (int r = 0; r < R; ++r) {
            for (int c = 0; c < C; ++c) {
                if (grid[r][c] != -1) {
                    todo++;
                }
                if (grid[r][c] == 1) {
                    sr = r;
                    sc = c;
                } else if (grid[r][c] == 2) {
                    tr = r;
                    tc = c;
                }
            }
        }
        ans = 0;
        dfs(sr, sc, todo);
        return ans;
    }

    public void dfs(int r, int c, int todo) {
        todo--;
        if (todo < 0) {
             return;
        }
        if (r == tr && c == tc) {
            if (todo == 0) {
                ans++;
            }
            return;
        }
        grid[r][c] = 3;
        for (int k = 0; k < 4; ++k) {
            int nr = r + dr[k];
            int nc = c + dc[k];
            if (0 <= nr && nr < R && 0 <= nc && nc < C) {
                if (grid[nr][nc] % 2 == 0) {
                    dfs(nr, nc, todo);
                }
            }
        }
        grid[r][c] = 0;
    }
}
