---
[![mjLPsI.png](https://s2.ax1x.com/2019/08/30/mjLPsI.png)](https://imgchr.com/i/mjLPsI)
- 说明：对10大排序算法进行概要总结；详细分析递归算法以及其应用案例。
<!--more--> 


### 10大排序算法
关于10大排序算法，可以找到很多的总结，如下图：
 
[![nSaFe0.png](https://s2.ax1x.com/2019/09/01/nSaFe0.png)](https://imgchr.com/i/nSaFe0)
关于稳定性

稳定的：冒泡、插入、归并和基数。

不稳定的：选择、快速、希尔、堆（记忆：不选快希堆）。

名词解释：

-  n：数据规模 
-  k："桶"的个数 
-  In-place：占用常数内存，不占用额外内存 
-  Out-place：占用额外内存 
-  稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同



10大排序算法时空复杂度让人很是头疼，不过最近网上看到了一则口诀（http://mashibing.com/?p=116），大家可以参考一下。

然后对上表进行了调整合并：
[![nSaCyn.jpg](https://s2.ax1x.com/2019/09/01/nSaCyn.jpg)](https://imgchr.com/i/nSaCyn)

[![nSaPLq.jpg](https://s2.ax1x.com/2019/09/01/nSaPLq.jpg)](https://imgchr.com/i/nSaPLq)

### 递归思想
递归(Recursion)是指在函数的定义中使用函数自身的方法

##### 递归解读
我们可以递归分为“**递**”和“**归**”两个过程。<br>
- 递：递去，深入，分解。待解决的问题可以分解为规模较小的相同子问题。
- 归：归来，回归，合并。

我们先思考以下问题：<br>
1.待求解的问题是否可以**重复分解**成小规模的问题？<br>
2.我们“递去”到什么程度，然后“归来”呢，哪里是“最深”的地方呢？<br>
3.在“最深处”，“递去”结束前，“归来”开始前，我们面对的是**最小子问题**，面对**最小子问题**我们的解决方式是什么？<br>

只要把以上三个问题的解决了，递归可以就轻松完成了。这也就是递归的三个要素：

- 1.重复的逻辑
- 2.递归的临界点
- 3.临界点的最小子问题的处理

前两个要素是确定的。第三个要素，可以提供两种解决思路：“递去”过程中解决;“归来”规程中解决。
```java
public class recursion{

    //在递去的过程中解决问题
    function recursion_01(大规模){
        if (临界条件){      
            end; 
        }else{            
            solve;                
            recursion(小规模);  // 递去
        }
    }

    //在归来的过程中解决问题
    function recursion_02(大规模){
        if (临界条件){     
            end; 
        }else{          
            recursion(小规模);   // 递去              
            solve;     
        }
     }
}
```
##### 递归转为非递归

- 1.用变量来保存中间结果
- 2.递归调用变为循环
 
##### 递归应用
###### 汉诺塔问题
###### 阶乘问题
###### 归并排序
###### 二分查找
###### 杨辉三角问题
###### 字符串回文问题
###### 数深度问题

### 时空复杂度





