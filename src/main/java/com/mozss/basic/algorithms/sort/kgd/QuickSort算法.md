- 快速排序（快排）：减少比较次数的冒泡排序。通过分治（递归实现）达到减少比较次数。

### 概要
##### 性质
- 不稳定
- 时间：O()
- 空间：O()

##### 算法思想


### 解读
##### 简要思路
（1）待排序列S,通过一次排序后要产生这样的结果：将S**切分**为S1和S2，并且 S1集合 < S2集合；<br>
（2）同理，将S1和S2进行操作（1）；<br>
（3）随着排序的深入（递归的深入），序列S整体逐渐取向于有序。<br>
- 总结：将S的排序问题，**分解**为若干个子序列的排序问题，**递归**求解子序列问题，最后**组合**子问题的解答。
#####算法解决的关键点
主要难点在于（1）中**切分**的解决方式。这里首先思考下面问题：<br>
1.将序列分成两拨，到底哪个数字是这两拨序列的边界呢？<br>
2.我们确定好边界之后，又如何**快速**将序列分为左右两拨呢？难道是第一趟找比边界小的元素，第二趟再找比边界大的元素吗？<br>

因此解决**划分**的三个关键点为：“基准元素”，“左游标”，“右游标”。
- 基准元素：以它为判断标准来界定大小值；一般，我们可以将序列的**第一个元素**作为基准元素。
- 左游标：找比基准小的元素；遇到**不小于基准**的值停下。
- 右游标：找比基准大的元素；遇到**不大于基准**的值停下。<br>

游标如何发挥作用？
- （1）移动：右游标先移动，遇到**不小于基准**的值停下。然后，左游标开始移动，遇到**不大于基准**的值停下。
- （2）交换：左右游标停止后，交换游标指向的元素值，完成第一次交换。
- （3）：继续（1）（2）操作，直到左右游标相遇。然后，“基准值”和“左右游标相遇停止时的元素值”进行交换，完成一轮操作
##### 算法图解
[![Kji4xK.md.png](https://s2.ax1x.com/2019/11/03/Kji4xK.md.png)](https://imgchr.com/i/Kji4xK)
### 实现

##### 实现方式1：数组

##### 实现方式2：链表


### 性能分析

##### 时间复杂度
##### 空间复杂度
##### 优化分析
假设我们是对一个逆序数组进行排序，选取第一个元素作为基准点，即最大的元素是基准点，那么第一次循环，左游标要执行到最右边，而右游标执行一次，
然后两者进行交换。这也会划分成很多的子数组。那么怎么解决呢？理想状态下，应该选择被排序数组的中值数据作为基准，也就是说一半的数大于基准数，
一般的数小于基准数，这样会使得数组被划分为两个大小相等的子数组，对快速排序来说，拥有两个大小相等的子数组是最优的情况。三项取中划分为了找
到一个数组中的中值数据，一般是取数组中第一个、中间的、最后一个，选择这三个数中位于中间的数。
```
//取数组下标第一个数、中间的数、最后一个数的中间值
private static int medianOf3(int[] array,int left,int right){
    int center = (right-left)/2+left;
    if(array[left] > array[right]){ //得到 array[left] < array[right]
        swap(array, left, right);
    }
    if(array[center] > array[right]){ //得到 array[left] array[center] < array[right]
        swap(array, center, right);
    }
    if(array[center] > array[left]){ //得到 array[center] <  array[left] < array[right]
        swap(array, center, left);
    }
    return array[left]; //array[left]的值已经被换成三数中的中位数， 将其返回
}
```
```
private static int partitionIt(int[] array,int left,int right){
    //为什么 j加一个1，而i没有加1,是因为下面的循环判断是从--j和++i开始的.
    //而基准元素选的array[left],即第一个元素，所以左游标从第二个元素开始比较
    int i = left;
    int j = right+1;
    int pivot = array[left];// pivot 为选取的基准元素（头元素）
     
    int size = right - left + 1;
    if(size >= 3){
        pivot = medianOf3(array, left, right); //数组范围大于3，基准元素选择中间值。
    }
    while(true){
        while(i<right && array[++i] < pivot){}
         
        while(j > 0 && array[--j] > pivot){}
         
        if(i >= j){// 左右游标相遇时候停止， 所以跳出外部while循环
            break;
        }else{
            swap(array, i, j);// 左右游标未相遇时停止, 交换各自所指元素，循环继续
        }
    }
    swap(array, left, j);//基准元素和游标相遇时所指元素交换，为最后一次交换
    return j;// 一趟排序完成， 返回基准元素位置(注意这里基准元素已经交换位置了)
}
```
处理小划分:如果使用三数据取中划分方法，则必须遵循快速排序算法不能执行三个或者少于三个的数据，如果大量的子数组都小于3个，
那么使用快速排序是比较耗时的。联想到前面我们讲过简单的排序（冒泡、选择、插入）。 当数组长度小于M的时候（high-low <= M），
不进行快排，而进行插入排序。转换参数M的最佳值和系统是相关的，一般来说， 5到15间的任意值在多数情况下都能令人满意。
```
//插入排序
private static void insertSort(int[] array){
    for(int i = 1 ; i < array.length ; i++){
        int temp = array[i];
        int j = i;
        while(j > 0 && array[j-1] > temp){
            array[j] = array[j-1];
            j--;
        }
        array[j] = temp;
    }
}
```
### 算法应用例子
- 源码地址：
##### 例子1：
##### 例子2：
##### 例子3：
