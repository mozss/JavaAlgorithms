- 访问者模式的目的是封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。

###引进
#####生活举例（这里插入图片或者文字简短描述）
#####UML结构图
![n4l8MR.png](https://s2.ax1x.com/2019/09/17/n4l8MR.png)
#####模式涉及到的角色（可有可无）
- 抽象访问者（Visitor）：声明一个或者多个访问操作，形成所有的具体元素角色以及客户端角色。

- 具体访问者（ConcreteVisitor）:实现抽象访问者角色所声明的接口，也就是抽象访问者所声明的各个访问操作。

- 抽象节点（Node）角色：声明一个接受操作，接受一个访问者对象作为一个参量。

- 具体节点（Node）角色：实现抽象元素所规定的接受操作。

- 结构对象（ObjectStructure）角色：有如下的一些责任，可以遍历结构中的所有元素；如果需要，提供一个高层次的接口让访问者对象可以访问每一
 个元素；如果需要，可以设计成一个复合对象或者一个聚集，如列（List）或者集合（Set）
#####模式的几种形态（可有可无）
######一：
######二：

###Demo实现
#####例子一：
#####例子二：

###应用
很多时候不使用设计模式反而会得到一个较好的设计。换言之，每一个设计模式都有其不应当的使用情况。访问者模式不适用下方情况：

-倾斜的可扩展性：<br>
 访问者模式仅应当在被访问的类结构非常稳定的情况下使用。换言之，系统很少出现需要加入新节点的情况。如果出现需要加入新节点的情况，
 这时候就需要在每一个访问对象里加入一个对应于这个新节点的访问操作，而这是对一个系统的大规模的修改，因此违背了“开-闭”原则。
 
 访问者模式允许在节点加入新的方法，相应的仅仅需要在一个新的访问者类中加入此方法，而不需要在每一个访问者类中都加入此方法。
 显然，访问者模式提供了倾斜的可扩展性设计：方法集合的可扩展性和类集合的不可以扩展性。
 
 换言之，如果系统的数据结构是频繁变化的，则不适合使用访问者模式。
 
- “开-闭”原则和对变化的封装<br>
 面向对象的设计原则中最重要的便是所谓的“开-闭”原则。一个软件系统的设计应该对扩展开放，对修改关闭。达到这个原则的途径就是遵循“对变化
 的封装”的原则。这个原则讲的是在进行软件系统的设计时，应当设法找出一个软件系统中会变化的部分，将之封装起来。
 
 很多系统中可以按照算法和数据结构的分开，也就是说一些对象包含算法，而另一些对象含有数据，接受算法的操作。如果这样的系统有比较稳定的
 数据结构，又有易于变化的算法的话，使用访问者模式就比较合适，因为访问者模式使得算法操作的增加变得容易。
 
 反过来，如果这样一个系统的数据结构对象易于变化，经常要有新的数据对象增加进来的话，就不适合使用访问者模式。因为在访问者模式中增加新的
 节点很困难，要涉及到在抽象访问者和所有的具体访问者中增加新的方法。

###实际使用情况
#####框架一
#####框架二

###优缺点

#####优点：

- 访问者模式使得增加新的操作变得很容易。如果一些操作依赖于一个一个复杂的结构对象的话，一般而言，增加新的操作会很复杂，而使用访问者模式，
 增加新的操作就意味着增加一个新的访问者类，因此，变得很容易。
 
- 访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。

- 访问者模式可以跨过几个类的等级结构访问不同等级结构的成员类。迭代子只能访问属于同一类型等级结构的成员对象，而不能访问属于不同等级结构
 的对象。访问者可以做到这一点。
 
- 积累状态。每一个单独的访问者对象都集中了相关的行为，从而也就可以在访问的过程中将执行操作的状态积累在子内部，而不是分散到很多节点对象
 中。这有益于系统维护。
 
#####缺点：

- 增加新的节点变得很困难。每增加一个新的节点都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作。

- 破坏封装。访问者模式要求访问者对象访问并调用每一个节点对象的操作，这隐含了一个对所有节点对象的要求：它们必须暴露一些自己的操作和内部状态。
 不然，访问者的访问就变得没有意义。由于访问者对象自己会积累访问操作所需的状态，从而使这些状态不再存储在节点对象中，这也是破坏封装的。
 
 由于显然的缺点，使得访问者模式成为一个有争议的设计模式。有一些设计师反对使用访问者模式，另外有一些强调优点，总之，需要工程师自己决定。

###与其他模式的区别与联系

###总结




