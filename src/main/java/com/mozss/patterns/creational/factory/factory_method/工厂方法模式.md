- 工厂方法（Factory Method）：定义一个用于创建产品的接口，由子类决定生产什么产品。

###引进
#####简单工厂的优缺点
在简单工厂模式中，一个工厂类处于对产品实例化的中心位置上，它知道每一个产品，他决定哪一个产品类应当被实例化，这个模式的优点是允许客户端
相对独立于产品创建的过程，并且在系统中引用新产品的时候无需修改客户端。也就是说，它在某种程度上支持“开-闭”原则。它的缺点也就是对“开-闭”
原则支持不够，因为如果有新的产品加入到系统去，需要修改这个工厂类，将必要的逻辑加入到工厂类中。
#####工厂方法模式的引进
由于使用多态性，工厂方法模式保存了简单工厂模式的优点，而且克服了它的确定。

首先，在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。这个核心类则摇身一变，成为一个抽象工厂角色。
仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。

这种进一步抽象化的结果，使这种工厂方法模式可以用来允许系统在不修改具体工厂角色的情况下引进新的产品，这一个特点无疑使得工厂模式具有超过简单
工厂模式的优越性。

下图所示是工厂方法模式的简略类图，这个类图中仅显示一个工厂类和一个产品类，在实际系统里面，会遇到多个产品类以及相应的工厂类：
![KhFT6f.png](https://s2.ax1x.com/2019/10/30/KhFT6f.png)
#####平行的等级结构
在一个系统设计中，常常是首先有产品角色，然后有工厂角色。在可以应用工厂方法模式的情形下，一般会有一个产品的等级结构，由一个（甚至多个）抽象
产品和多个具体产品组成。产品的等级结构如下图，树图中有阴影的是树枝型节点：
![KhkfDU.png](https://s2.ax1x.com/2019/10/30/KhkfDU.png)
在上面的产品等级结构中，出现了多于一个的抽象产品，以及多于两个的层次。这其实是真实的系统中常常出现的情况。当将工厂方法模式应用到这个系统
中去的时候，常常采用的一个做法是按照产品的等级结构设计一个同结构的工厂等级结构，工厂的等级结构如下图所示，树图中有阴影的是树枝型节点。
![KhA1MV.png](https://s2.ax1x.com/2019/10/30/KhA1MV.png)
然后由相应的工厂角色创建相应的产品角色，工厂方法模式的应用如下图所示，图中的虚线代表创建（依赖关系）
![KhAtIJ.png](https://s2.ax1x.com/2019/10/30/KhAtIJ.png)
工厂方法模式并没有限制产品等级结构的层数，一般的书籍中都以两层为例，第一层是抽象产品层，第二层是具体产品层，但在实际的系统中，产品常常有更为
复杂的层次。
#####工厂方法UML结构图
![KhEneO.png](https://s2.ax1x.com/2019/10/30/KhEneO.png)
#####模式涉及到的角色
######抽象工厂（Creator）角色:
担任这个角色的是工厂方法模式的核心，它是与应用程序无法的。任何在模式中创建对象的工厂类必须实现这个接口。在上面的系统中，这个角色由Java接口Creator
扮演；在实际的系统中，这个角色也常常使用抽象Java类实现。
#####具体工厂（Concrete Creator）角色：
担任这个角色的是实现了抽象工厂接口的具体Java类，具体工厂类含有与应用密切相关的逻辑，并且受到应用程序的调用以创建产品对象。在本系统中给出
两个这样的角色，也就是具体Java类ConcreteCreator1和ConcreteCreator2
#####抽象产品（Product）角色：
工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。在例中，这个角色由Java接口Prodeuct扮演;在实际的系统中，这个
角色也常常使用抽象Java类实现。
#####抽象产品（ConcreteProduct）:
这个角色实现了抽象产品角色所声明的接口。工厂方法模式所创建的每一个对象都是某个具体产品角色的实例。

######二：
#####模式的几种形态（可有可无）
######一：
######二：

###Demo实现
#####例子一：
#####例子二：

###应用
#####应用一（文字加举例）
#####应用一（文字加举例）

###实际使用情况
#####框架一
#####框架二

###优缺点
#####优点
- 优点一：
- 优点二：
- 优点三：
#####缺点
- 缺点一：
- 缺点二：
- 缺点三：

###与其他模式的区别与联系

- 工厂方法模式和简单工厂模式
工厂方法模式和简单工厂模式在结构上的不同是很明显的。工厂方法模式的核心是一个抽象工厂类，而简单工厂的核心类放在一个具体类上。工厂方法模式
可以允许很多具体工厂类从抽象工厂类中将创建行为继承下来，从而可以成为多个简单工厂模式的综合，进而推广了简单工厂模式。

工厂方法模式退化后可以变得很像简单工厂模式。设想如果非常确定一个系统只需要一个具体工厂类，你们就不妨把抽象工厂类合并到具体的工厂类中。由于
只有一个具体工厂类，所以不妨把工厂方法给为静态方法，这就得到简单工厂模式。

与简单工厂模式中的情形一样的是，ConcreteCreator的factory()方法返还的数据类型是一个抽象类型Prodect，而不是哪一个具体产品类型，而客户端
也不必知道所得到的产品的真实类型。这种多态性设计将工厂类选择穿甲哪一个产品对象，如何创建这个对象的细节完全封装在具体工厂类内部。

工厂方法模式之所以有一个别名叫做多态性工厂模式，显然是因为具体工厂类都有共同的接口，或者都有共同的抽象父类。

如果系统需要加入一个新的产品，那么所需要的就是向系统中加入一个这个产品以及它所对应的工厂类。没有必要修改客户端，也没有必要修改抽象工厂角色
或者其他已有的具体工厂角色。对于增加新的产品类而言，这个系统完全支持“开-闭”原则。


###总结






























