- 享元模式以共享的方式高效地支持大量的细粒度对象。

###引进

#####举例
- 在编辑器系统中使用到。一个文本编辑器往往含有很多字体，通常的做法是将每一个字母做成一个享元对象。
- Java的String类型中。String对象是不变对象，一旦创建了就不能改变。如果需要改变，则需要创建一个新的String对象。
  如果在系统中，有两个String对象包含的字符串相同的话，JVM实际上只创建一个String对象并提供了两个引用。String的intern()方法给出这个
  字符串在共享池中唯一示例。
  
 #####什么是享元
 - 内蕴状态：存储在享元对象内部，不随环境改变而改变。因此一个享元可以具有具备状态并可以共享。
 - 外蕴状态：随环境的改变而改变，不可共享的状态。享元对象的外蕴状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到
 享元对象的内部。
 
 **两种状态是独立的，不会相互影响。**

###模式的几种形态
根据所涉及的享元对象的内部表象，可以分为两种形式：
####单纯享元
[![nf7RF1.png](https://s2.ax1x.com/2019/09/16/nf7RF1.png)](https://imgchr.com/i/nf7RF1)
#####UML结构图
![KRoi1f.png](https://s2.ax1x.com/2019/10/29/KRoi1f.png)
#####模式涉及到的角色（可有可无）
######抽象享元角色：
此角色是所有的具体享元类的超类，为这些类规定出需要实现的公共接口。那些需要外蕴状态（ExternalState）的操作可以通过调用商业方法以参数
形式传入。
######具体享元（ConcreteFlyWeight）角色：
实现抽象享元角色多规定的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。享元对象的内蕴状态必须与对象所处的周围环境无关，从而
使得享元对象可以在系统内共享。
######享元工厂（FlyweightFactory）角色：
本角色负责创建和管理享元角色，本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统
中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元
工厂角色就应当创建一个合适的享元对象。
######客户端（Client）角色：
本角色可以维护一个对所有享元对象的引用。本角色需要自行存储所有享元对象的外蕴状态。











####复合享元（单纯享元+复合享元）
[![nf7oOe.png](https://s2.ax1x.com/2019/09/16/nf7oOe.png)](https://imgchr.com/i/nf7oOe)
#####UML结构图
![KfAQpt.png](https://s2.ax1x.com/2019/10/29/KfAQpt.png)
#####模式涉及到的角色
######抽象享元角色：
此角色是所有的具体享元类的超类，为这些类规定出需要实现的公共接口。那些需要外蕴状态（ExternalState）的操作可以通过方法的参数传入。
抽象享元的接口使得享元变得可能，但是并不强制子类实行共享，因此并非所有的享元对象都是可以共享的。
######具体享元（ConcreteFlyweight）角色：
实现抽象享元角色所规定的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。享元对象的内蕴状态必须与对象所处的周围环境无关，从而
使得享元对象可以在系统内共享。有时候具体享元角色又叫单纯具体享元角色，因为复合享元角色是有单纯具体享元角色通过复合而成的。
######复合享元对象（UnsharableFlyweight）角色：
复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称为不可以共享的享元
对象。
######享元工厂（FlyweightFactory）角色：
本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当共享。当一个客户端对象请求一个享元对象的时候，享元工厂角色需要检查系统中
是否已经有一个符合要求的享元对象，如果有了，享元工厂角色就应当提供这个已有的享元对象，如果系统中没有一个适当的享元对象的话，享元工厂角色
就应当创建一个新的合适的享元对象。
######客户端（Client）角色：
本角色还需要自行存储所有享元对象的外蕴状态。

###Demo实现
#####例子一：
#####例子二：

###应用
- 需要扩展一个类的功能，或给一个类增加附加的责任；
- 需要动态地给一个对象增加功能，这些功能可以再动态地撤销；
- 需要增加有一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变得不现实。

###实际使用情况
#####框架一
#####框架二

###优缺点
#####优点
可以大幅度降低内存中对象的数量
#####缺点
- 使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这就使得程序的逻辑复杂化。
- 享元模式将享元的状态外部化，而读取外部状态使得运行时间稍晚变长。
###与其他模式的区别与联系

###总结




