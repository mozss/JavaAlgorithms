- 装饰者模式动态的给对象增加一些职责，即增加其额外的功能。
###引进
装饰者模式以对客户端透明的方式扩展对象的功能，是基层关系的一种替代方案。

#####生活举例（这里插入图片或者文字简短描述）
#####UML结构图
![K2h1HI.png](https://s2.ax1x.com/2019/10/29/K2h1HI.png)

#####模式涉及到的角色
######抽象构建（Component）角色：
给出有一个抽象接口，以规范准备接受附加责任的对象
######具体构建（Concrete Component）角色：
定义一个将要接受附加责任的类
######装饰（Decorator）角色：
持有一个构建（Component）对象的实例，并定义一个与抽象构建接口一致的接口
######具体装饰（Concrete Decorator）角色：
负责给构建对象“贴上”附加的责任。

###对象图
装饰模式的对象图呈现链状结构，其共有三个具体装饰类，分别称为Decorator1,Decorator2,Decorator3,具体架构类是ConcreteComponent。一个
典型的创建过程如下代码
```
    new Decorator1(
            new Decorator2(
                    new Decorator3(
                            new ConcreteComponent()
                    )
            )       
     )
```
这就意味着Decorator1对象持有一个对Decorator2对象的引用，后者则持有一个对Decorator3的引用，在后者持有一个对具体构建ConcreteCompetition
对象的引用，这种链式的引用关系使用装饰者模式看上去就像一个LinkedList，如下图：
![K25FFx.png](https://s2.ax1x.com/2019/10/29/K25FFx.png)
装饰者模式常常被称为包裹模式，就是因为每一个具体装饰类都将下一个具体装饰类或者具体构件类包裹起来，如下图：
![K25umd.png](https://s2.ax1x.com/2019/10/29/K25umd.png)

#####模式的几种形态（可有可无）
######一：
######二：

###Demo实现
#####例子一：
#####例子二：

###应用
#####应用一（文字加举例）
#####应用一（文字加举例）

###典型应用
- 需要扩展一个类的功能，或给一个类增加附加的责任；
- 需要动态地给一个对象增加功能，这些功能可以再动态地撤销；
- 需要增加有一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变得不现实。


###实际使用情况
#####框架一
#####框架二

###优缺点
#####优点
- 装饰模式与继承关系的目的都是为了扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态地决定“贴上”一个需要的“装饰”，
或者除掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。
- 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同的行为组合。
#####缺点
- 这种比继承更加灵活的特性，也就意味着比继承更加容易出错。由于装饰模式，可以比使用继承关系需要更加少数目的类，使用较少的类，当然使设计
比较易于进行，但是，另一方面，使用装饰模式会产生比使用继承关系更多的对象，更多的对象会使得差错变得困难，特别是对象看上去很相像的时候。

###与其他模式的区别与联系

###总结




