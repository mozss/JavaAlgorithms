在二叉树中，每个节点只有一个数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树。

2-3-4树，它是一种多叉树，它的每个节点最多有四个子节点和三个数据项。
### 2-3-4树
2-3-4树每个节点最多有四个字节点和三个数据项，名字中 2,3,4 的数字含义是指一个节点可能含有的子节点的个数。对于非叶节点有三种可能的情况：
①、有一个数据项的节点总是有两个子节点；
②、有二个数据项的节点总是有三个子节点；
③、有三个数据项的节点总是有四个子节点；
简而言之，非叶节点的子节点数总是比它含有的数据项多1。如果子节点个数为L，数据项个数为D，那么：L = D + 1
![MmkjHK.png](https://s2.ax1x.com/2019/11/09/MmkjHK.png)
叶节点（上图最下面的一排）是没有子节点的，然而它可能含有一个、两个或三个数据项。空节点是不会存在的。
树结构中很重要的一点就是节点之间关键字值大小的关系。在二叉树中，所有关键字值比某个节点值小的节点都在这个节点左子节点为根的子树上；
所有关键字值比某个节点值大的节点都在这个节点右子节点为根的子树上。2-3-4 树规则也是一样，并且还加上以下几点：
为了方便描述，用从0到2的数字给数据项编号，用0到3的数字给子节点编号，如下图：
![MmAS4e.png](https://s2.ax1x.com/2019/11/09/MmAS4e.png)

①、根是child0的子树的所有子节点的关键字值小于key0；<br>
②、根是child1的子树的所有子节点的关键字值大于key0并且小于key1；<br>
③、根是child2的子树的所有子节点的关键字值大于key1并且小于key2；<br>
④、根是child3的子树的所有子节点的关键字值大于key2。<br>
简化关系如下图，由于2-3-4树中一般不允许出现重复关键值，所以不用考虑比较关键值相同的情况。<br>

![MmAuCQ.png](https://s2.ax1x.com/2019/11/09/MmAuCQ.png)
### 搜索2-3-4树
![MmAYUU.png](https://s2.ax1x.com/2019/11/09/MmAYUU.png)
### 插入
新的数据项一般要插在叶节点里，在树的最底层。如果你插入到有子节点的节点里，那么子节点的编号就要发生变化来维持树的结构，因为在2-3-4树中节点的子节点要比数据项多1。

插入操作有时比较简单，有时却很复杂。

①、当插入没有满数据项的节点时是很简单的，找到合适的位置，只需要把新数据项插入就可以了，插入可能会涉及到在一个节点中移动一个或其
他两个数据项，这样在新的数据项插入后关键字值仍保持正确的顺序。如下图：
![MmAc5D.png](https://s2.ax1x.com/2019/11/09/MmAc5D.png)
②、如果往下寻找插入位置的途中，节点已经满了，那么插入就变得复杂了。发生这种情况时，节点必须分裂，分裂能保证2-3-4树的平衡。
ps：这里讨论的是自顶向下的2-3-4树，因为是在向下找到插入点的路途中节点发生了分裂。把要分裂的数据项设为A,B,C，下面是节点分裂的情况
（假设分裂的节点不是根节点）：
#####节点分裂
1、节点分裂

一、创建一个新的空节点，它是要分裂节点的兄弟，在要分裂节点的右边；

二、数据项C移到新节点中；

三、数据项B移到要分裂节点的父节点中；

四、数据项A保留在原来的位置；

五、最右边的两个子节点从要分裂处断开，连到新节点上。
![MmA5rt.png](https://s2.ax1x.com/2019/11/09/MmA5rt.png)


#####根的分裂
如果一开始查找插入节点时就碰到满的根节点，那么插入过程更复杂：

①、创建新的根节点，它是要分裂节点的父节点。

②、创建第二个新的节点，它是要分裂节点的兄弟节点；

③、数据项C移到新的兄弟节点中；

④、数据项B移到新的根节点中；

⑤、数据项A保留在原来的位置；

⑥、要分裂节点最右边的两个子节点断开连接，连到新的兄弟节点中。
![MmA7a8.png](https://s2.ax1x.com/2019/11/09/MmA7a8.png)
上图便是根分裂的情况，分裂完成之后，整个树的高度加1。另外一种描述根分裂的方法是说4-节点变成三个2-节点。

注意：插入时，碰到没有满的节点时，要继续向下寻找其子节点进行插入。如果直接插入该节点，那么还要进行子节点的增加，
因为在2-3-4树中节点的子节点个数要比数据项多1；如果插入的节点满了，那么就要进行节点分裂。下图是一系列插入过程，有4个节点分裂了，
两个是根，两个是叶节点：
![MmEpZV.png](https://s2.ax1x.com/2019/11/09/MmEpZV.png)
###完整的源码实现
见目录
###2-3-4树和红黑树
2-3-4树是多叉树，而红黑树是二叉树，看上去可能完全不同，但是，在某种意义上它们又是完全相同的，一个可以通过应用一些简单的规则变成另一个，
而且使他们保持平衡的操作也是一样，数学上称他们为同构。

#####对应规则
应用如下三条规则可以将2-3-4树转化为红黑树：
- 把2-3-4树中的每个2-节点转化为红-黑树的黑色节点。
- 把每个3-节点转化为一个子节点和一个父节点，子节点有两个自己的子节点：W和X或X和Y。父节点有另一个子节点：Y或W。
哪个节点变成子节点或父节点都无所谓。子节点涂成红色，父节点涂成黑色。
- 把每个4-节点转化为一个父节点和两个子节点。第一个子节点有它自己的子节点W和X；第二个子节点拥有子节点Y和Z。和前面一样，
子节点涂成红色，父节点涂成黑色。
![MmFsQ1.png](https://s2.ax1x.com/2019/11/09/MmFsQ1.png)
##### 操作等价
![MmFysx.png](https://s2.ax1x.com/2019/11/09/MmFysx.png)
### 2-3-4树的效率
析2-3-4树我们可以和红黑树作比较分析。红-黑树的层数（平衡二叉树）大约是log2(N+1)，而2-3-4树每个节点可以最多有4个数据项，
如果节点都是满的，那么高度和log4N。因此在所有节点都满的情况下，2-3-4树的高度大致是红-黑树的一半。不过他们不可能都是满的，
所以2-3-4树的高度大致在log2(N+1)和log2(N+1)/2。减少2-3-4树的高度可以使它的查找时间比红-黑树的短一些。 但是另一方面，
每个节点要查看的数据项就多了，这会增加查找时间。因为节点中用线性搜索来查看数据项，使得查找时间的倍数和M成正比，即每个节点
数据项的平均数量。总的查找时间和M*log4N成正比。